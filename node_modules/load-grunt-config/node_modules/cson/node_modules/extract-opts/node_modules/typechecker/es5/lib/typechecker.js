'use strict';

// Character positions

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var INDEX_OF_FUNCTION_NAME = 9; // "function X", X is at index 9
var FIRST_UPPERCASE_INDEX_IN_ASCII = 65; // A is at index 65 in ASCII
var LAST_UPPERCASE_INDEX_IN_ASCII = 90; // Z is at index 90 in ASCII

// Module
module.exports = function () {
	function TypeChecker() {
		_classCallCheck(this, TypeChecker);
	}

	_createClass(TypeChecker, null, [{
		key: 'getTypes',

		// -----------------------------------
		// Helpers

		// Get an array of the available types in CamelCase
		value: function getTypes() {
			return ['Array', 'Boolean', 'Date', 'Error', 'Class', 'Function', 'Null', 'Number', 'RegExp', 'String', 'Undefined', 'Map', 'WeakMap', 'Object' // deliberately last, as this is a catch all
			];
		}

		// Get the type of the value in lowercase

	}, {
		key: 'getType',
		value: function getType(value) {
			// Cycle the keys of this class
			var types = this.getTypes();
			for (var i = 0; i < types.length; ++i) {
				var type = types[i];
				if (this['is' + type](value)) {
					return type.toLowerCase();
				}
			}

			// Return
			return null;
		}

		// Get the object type string

	}, {
		key: 'getObjectType',
		value: function getObjectType(value) {
			return Object.prototype.toString.call(value);
		}

		// -----------------------------------
		// Values

		// Checks to see if a value is an object and only an object

	}, {
		key: 'isPlainObject',
		value: function isPlainObject(value) {
			/* eslint no-proto:0 */
			return this.isObject(value) && value.__proto__ === Object.prototype;
		}

		// Checks to see if a value is empty

	}, {
		key: 'isEmpty',
		value: function isEmpty(value) {
			return value == null;
		}

		// Is empty object

	}, {
		key: 'isEmptyObject',
		value: function isEmptyObject(value) {
			// We could use Object.keys, but this is more effecient
			for (var key in value) {
				if (value.hasOwnProperty(key)) {
					return false;
				}
			}
			return true;
		}

		// Is ES6+ class
		// If changed, isClass must also be updated

	}, {
		key: 'isNativeClass',
		value: function isNativeClass(value) {
			return typeof value === 'function' && value.toString().indexOf('class') === 0;
		}

		// Is Conventional Class
		// Looks for function with capital first letter MyClass
		// First letter is the 9th character
		// If changed, isClass must also be updated

	}, {
		key: 'isConventionalClass',
		value: function isConventionalClass(value) {
			var c = undefined;return typeof value === 'function' && (c = value.toString().charCodeAt(INDEX_OF_FUNCTION_NAME)) >= FIRST_UPPERCASE_INDEX_IN_ASCII && c <= LAST_UPPERCASE_INDEX_IN_ASCII;
		}

		// There use to be code here that checked for CoffeeScript's "function _Class" at index 0 (which was sound)
		// But it would also check for Babel's __classCallCheck anywhere in the function, which wasn't sound
		// as somewhere in the function, another class could be defined, which would provide a false positive
		// So instead, proxied classes are ignored, as we can't guarantee their accuracy, would also be an ever growing set

		// -----------------------------------
		// Types

		// Is Class

	}, {
		key: 'isClass',
		value: function isClass(value) {
			/* eslint no-extra-parens:0 */
			var s = undefined,
			    c = undefined;return typeof value === 'function' && ((s = value.toString()).indexOf('class') === 0 || (c = s.charCodeAt(INDEX_OF_FUNCTION_NAME)) >= FIRST_UPPERCASE_INDEX_IN_ASCII && c <= LAST_UPPERCASE_INDEX_IN_ASCII);
		}

		// Checks to see if a value is an object

	}, {
		key: 'isObject',
		value: function isObject(value) {
			// null and undefined are objects, hence the truthy check
			return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
		}

		// Checks to see if a value is an error

	}, {
		key: 'isError',
		value: function isError(value) {
			return value instanceof Error;
		}

		// Checks to see if a value is a date

	}, {
		key: 'isDate',
		value: function isDate(value) {
			return this.getObjectType(value) === '[object Date]';
		}

		// Checks to see if a value is an arguments object

	}, {
		key: 'isArguments',
		value: function isArguments(value) {
			return this.getObjectType(value) === '[object Arguments]';
		}

		// Checks to see if a value is a function

	}, {
		key: 'isFunction',
		value: function isFunction(value) {
			return this.getObjectType(value) === '[object Function]';
		}

		// Checks to see if a value is an regex

	}, {
		key: 'isRegExp',
		value: function isRegExp(value) {
			return this.getObjectType(value) === '[object RegExp]';
		}

		// Checks to see if a value is an array

	}, {
		key: 'isArray',
		value: function isArray(value) {
			return Array.isArray && Array.isArray(value) || this.getObjectType(value) === '[object Array]';
		}

		// Checks to see if a valule is a number

	}, {
		key: 'isNumber',
		value: function isNumber(value) {
			return typeof value === 'number' || this.getObjectType(value) === '[object Number]';
		}

		// Checks to see if a value is a string

	}, {
		key: 'isString',
		value: function isString(value) {
			return typeof value === 'string' || this.getObjectType(value) === '[object String]';
		}

		// Checks to see if a valule is a boolean

	}, {
		key: 'isBoolean',
		value: function isBoolean(value) {
			return value === true || value === false || this.getObjectType(value) === '[object Boolean]';
		}

		// Checks to see if a value is null

	}, {
		key: 'isNull',
		value: function isNull(value) {
			return value === null;
		}

		// Checks to see if a value is undefined

	}, {
		key: 'isUndefined',
		value: function isUndefined(value) {
			return typeof value === 'undefined';
		}

		// Checks to see if a value is a Map

	}, {
		key: 'isMap',
		value: function isMap(value) {
			return this.getObjectType(value) === '[object Map]';
		}

		// Checks to see if a value is a WeakMap

	}, {
		key: 'isWeakMap',
		value: function isWeakMap(value) {
			return this.getObjectType(value) === '[object WeakMap]';
		}
	}]);

	return TypeChecker;
}();